sort 
	Door = struct D1|D2|D3|D4; %each door that we have
	Sluice = struct Sluice1|Sluice2; %the two sluices
	Robot = struct R1|R2|R3; %the three robots
	DoorType = struct Inside|Outside; %the placement of the doors
	%WaitingRack = struct Unprojected ? isUnprojectedEmtpy | Projected ? isProjectedEmpty; %waiting racks, with ways to check if they are empty or not
	%OutsideRack = struct Input|Output; %outside racks

	Rack = struct WaitingRackInput ? isWaitingRackInputEmtpy | WaitingRackOutput ? isWaitingRackOutputEmpty | Input | Output;
	Wafer = struct Unprojected | Projected;
	Position = struct IR|S1|S2|WR_I|WR_O|IPS|OR;
	Status = struct Empty|Full;
act 
  	closeDoor, openDoor, stuckDoor: Sluice # DoorType; %closing and opening a door: we map this to a sluice and its door type
	pump: Sluice; %pumping the air out of a sluice
	moveRobot : Position # Position;

	placeWafer_Sent, placeWafer_Received, placeWafer: Robot # Position # Wafer; 
	receivedWafer, giveWafer, waferPlaced: Position # Wafer; %place wafer into a sluice
	pickUpWafer_Sent, pickUpWafer_Received, pickUpWafer: Robot # Position # Wafer;
	
	waferSignal_Sent, waferSignal_Received, waferSignal: Robot # Position # Wafer;
	waferHere_Sent, waferHere_Received, waferHere: Robot # Position # Wafer;

	move: Robot # Position # Position;

	waferTest: Wafer;
	
	moveRequestToSluice_Sent, moveRequestToSluice_Received, moveRequestToSluice: Robot # Sluice;
	moveResponseFromSluice_Sent, moveResponseFromSluice_Received, moveResponseFromSluice: Sluice # Bool; 
	moveRequestToRack_Sent, moveRequestToRack_Received, moveRequestToRack: Robot # Rack;
	moveResponseFromRack_Sent, moveResponseFromRack_Received, moveResponseFromRack: Rack # Bool;
	moveSuccess_Sent, moveSuccess_Received, moveSuccess: Sluice;
	moveFailed_Sent, moveFailed_Received, moveFailed: Robot;
	%doorOpenRequest_Send, doorOpenRequest_Response: Sluice # Door;
	%doorCloseRequest_Send, doorCloseRequest_Response: Sluice # Door;

map
	sluiceDoor: Sluice # DoorType -> Door; %we map each door to a sluice and a placement, for example D1 is the outside door of sluice1
	sluiceToPosition: Sluice -> Position;

	rackToPosition: Rack -> Position;

eqn
	%sluice mappings
	sluiceToPosition(Sluice1) = S1;
	sluiceToPosition(Sluice2) = S2;
	
	%door mappings
	sluiceDoor(Sluice1, Outside) = D1;
	sluiceDoor(Sluice1, Inside) = D2;
	sluiceDoor(Sluice2, Outside) = D3;
	sluiceDoor(Sluice2, Inside) = D4;

	%rack mappings
	rackToPosition(Input) = IR;
	rackToPosition(Output) = OR;
	rackToPosition(WaitingRackInput) = WR_I;
	rackToPosition(WaitingRackOutput) = WR_O;

proc
	
	

	outsideRobot = 
		(moveToSluice(R1, IR, Unprojected)).outsideRobot; %+ moveToRack(R1, Output, S2) + moveToRack(R1, Output, S1)).outsideRobot;
	
	%insideRobot = 
	%	(moveToRack(R2, WaitingRackInput, Unprojected) + moveToSluice(R2, )).insideRobot

	moveToSluice(r: Robot, p: Position, w: Wafer) =
		sum s: Sluice.(moveRequestToSluice_Sent(r,s).(moveResponseFromSluice_Received(s, true).move(r,sluiceToPosition(s),p).moveSuccess_Sent(s) 
													+ moveResponseFromSluice_Received(s, false).moveFailed_Sent(r)));
	

	sluiceOperation(s: Sluice, outsideOpen: Bool, insideOpen: Bool, outsideStuck: Bool, insideStuck: Bool) =
			(!insideOpen && !outsideOpen) -> 
				sum r: Robot.moveRequestToSluice_Received(r,s). 
					(((r == R1) -> 
						openDoor(s, Outside).pump(s).moveResponseFromSluice_Sent(s, true).moveSuccess_Received(s).sluiceOperation(s, true, false, false, false)) + 
					((r == R2) -> 
						openDoor(s, Inside).pump(s).moveResponseFromSluice_Sent(s, true).moveSuccess_Received(s).sluiceOperation(s, false, true, false, false)));

	%moveToRack(r: Robot, ra: Rack, p: Position) = 
	%	moveRequestToRack_Sent(r, ra).(moveResponseFromRack_Received(ra, true).move(r, rackToPosition(ra), p) + moveResponseFromRack_Received(ra, false));
	

	%rackOperation(ra: Rack) = 
%		sum r: Robot.moveRequestToRack_Received(r, ra).(
	%	(ra == Input) -> 
	%		(moveResponseFromRack_Sent(ra, true)) + 
	%	(ra == Output) -> 
		%	(moveResponseFromRack_Sent(ra, true)) +
		%(ra == WaitingRackInput) ->
		%	(moveResponseFromRack_Sent(ra, false)) +
		%(ra == WaitingRackOutput) -> 
		%	(moveResponseFromRack_Sent(ra, false)));
		
	%waferOperation(p: Position, w: Wafer) =
	%	sum r: Robot.waferSignal_Received(r, p, w).
	%	(((r == R1 && (p == S1 || p == S2) && w == Unprojected) ->
	%		placeWafer_Sent(r, p, w)) +
	%	((r == R1 && (p == S1 || p == S2) && w == Projected) ->
	%		pickUpWafer_Sent(r, p, w)) +
%	
	%	((r == R2 && (p == S1 || p == S2) && w == Unprojected) ->
	%		pickUpWafer_Sent(r, p, w)) +
	%	((r == R1 && (p == S1 || p == S2) && w == Projected) ->
		%	placeWafer_Sent(r, p, w)));

	%waferStatus();


	%we close the inside door, open the outside door, and after that, we can follow up with the inside door opening sequence
    %SluiceOutOpen(s:Sluice, outsideOpen: Bool, insideOpen: Bool, r: Robot) = 
	%sum r: Robot, sl: Sluice.(moveRequestToSluice_   
	%moveRequestToSluice_Received(r, s, sluiceDoor(s, Outside)).openDoor(s, Outside).moveResponseFromSluice_Sent(r, s, sluiceDoor(s, Outside), true);
	%we close the outside door, pump the air out, open the inside door, and after that, we can follow up with the outside door opening sequence
	%SluiceInOpen(s:Sluice) = closeDoor(s, Outside).pump(s).openDoor(s, Inside).SluiceOutOpen(s);
	%RobotOut = SluiceOutOpen(Sluice1).moveRobot(IR,S1).placeWafer(Sluice1) + SluiceOutOpen(Sluice2).moveRobot(IR,S2).placeWafer(Sluice2) ;
	%RobotIn = 

init
  allow(
    { closeDoor, openDoor, pump, moveRequestToSluice, moveResponseFromSluice, moveRequestToRack, moveResponseFromRack, move, placeWafer, pickUpWafer, waferPlaced, waferSignal, moveSuccess, moveFailed},
		comm(
			{moveRequestToSluice_Sent | moveRequestToSluice_Received -> moveRequestToSluice,
			moveResponseFromSluice_Sent | moveResponseFromSluice_Received -> moveResponseFromSluice,
			moveRequestToRack_Sent | moveRequestToRack_Received  -> moveRequestToRack,
			moveResponseFromRack_Sent | moveResponseFromRack_Received -> moveResponseFromRack,
			placeWafer_Sent | placeWafer_Received -> placeWafer,
			pickUpWafer_Sent | pickUpWafer_Received -> pickUpWafer,
			waferSignal_Sent | waferSignal_Received -> waferSignal,
			moveFailed_Sent | moveFailed_Received -> moveFailed,
			moveSuccess_Sent | moveSuccess_Received -> moveSuccess},
			
			outsideRobot || sluiceOperation(Sluice1, false, false, false, false) || sluiceOperation(Sluice2, false, false, false, false) %|| %rackOperation(Output)  %|| waferOperation(R1, S1, Unprojected) || waferOperation(R1, S2, Unprojected)
    	
       	%SluiceOutOpen(Sluice1) || SluiceInOpen(Sluice2)||RobotOut %just an example start: we can either open the outside of sluice1 or open the inside of sluice 2, these can go paralell
		%SluiceOutOpen(Sluice1, false, false, R1)
   )) ;

%comment