
   
sort 
  Sluice = struct S1|S2; %the two sluices
  Robot = struct R1|R2; %the three robots
  DoorType = struct Inside|Outside; %the placement of the doors
  %WaitingRack = struct Unprojected ? isUnprojectedEmpty | Projected ? isProjectedEmpty; %waiting racks, with ways to check if they are empty or not
  %OutsideRack = struct Input|Output; %outside racks
  Position = struct IR|WR_I|WR_O|OR|IPS|S1_Out|S1_In|S2_Out|S2_In;
 % Status = struct Empty?isEmpty|Full|UnProjected|Projected?isProjected;
  %PositionStatus = Position -> Status;
  %Component = struct R1|R2;
  Wafer = struct Empty | Projected | Unprojected;

map 
  %GreenSig : Position -> Status;
  %SluiceDoor : Sluice # DoorType;
 % Initial : Position->Status;
  %Update : PositionStatus # Position # Position -> PositionStatus;
  SluiceMap : Sluice # DoorType -> Position;

var
  p:Position;
 % ps:PositionStatus;
  src,des:Position;
  %sd:SluiceDoor;

eqn
  %Initial(p)=Empty; 

  SluiceMap(S1,Outside)=S1_Out;
  SluiceMap(S1,Inside)=S1_In;
  SluiceMap(S2,Outside)=S2_Out;
  SluiceMap(S2,Inside)=S2_In;

  %Every Move of R1 and R2 from Src to Des results in Des_State = Src_State and Src_State=Empty
  %Update(ps,src,des) = ps[des->ps(src)][src->Empty];
  

act  
  closeDoor, openDoor,isClose,isOpen,sigOpen,sigClose,Open,Close,MoveThrough: Sluice # DoorType;
  pump: Sluice; %pumping the air out of a sluice
  Move,MoveOK,MoveReq: Position # Position;
  
	waferStatusUpdateSent, waferStatusUpdateReceived, waferStatusUpdate: Position # Wafer;
	waferBroadcastSent, waferBroadcastReceived, waferBroadcast: Position # Wafer;
  
  %doorStuck : Position;

proc 

  % S1 and S2 opening sequence : Check if inside door is closed, if yes then open the outside door and send sigOpen signal
                  %Check if outside door is closed, if yes then pump air out, and open the inside door and send sigOpen signal  
   
   SluiceOpen(s:Sluice,d:DoorType) = (isClose(s,Inside).sigOpen(s,Outside).(SluiceOpen(s,Outside)) +                               
                    isClose(s,Outside).sigOpen(s,Inside).(pump(s).SluiceOpen(s,Inside)));
  % S1 and S2 Closing sequence : Check if door is open, if yes then close the door and send sigClose signal     
   SluiceClose(s:Sluice,d:DoorType) = (isOpen(s,Outside).sigClose(s,Outside).SluiceClose(s,Outside))+(isOpen(s,Inside).sigClose(s,Inside).SluiceClose(s,Inside));
   SluiceControl(s:Sluice,d:DoorType) = sum s:Sluice. sum d:DoorType.MoveThrough(s,d).(isClose(s,d).SluiceOpen(s,d)+ isOpen(s,d).SluiceClose(s,d)).SluiceControl(s,d);
	Sluice(s:Sluice, outsideDoor:Bool, insideDoor:Bool, outsideStuck: Bool, insideStuck: Bool) = (outsidedoor=false && insidedoor = false) -> signalOpen(s,Outside) . SluiceOpen(s,Oustide) . Sluice(outsidedoor=true) +

  % R1 can pickup wafers only from IR,S1_Out or S2_Out and place wafers only S1_Out,S2_Out or OR
  % R2 can pickup wafers only from S1_In,S2_In,WR_I,WR_O and place wafers only S1_In,S2_In,WR_I
   %Robot1  =  sum s:Sluice.(((waferBroadcastReceived(SluiceMap(s, Inside), projected) + waferBroadcastReceived(SluiceMap(s, Outside), projected).(MoveReq(SluiceMap(s,Outside),OR) + 
	%						waferBroadcastReceived(IR, unprojected).MoveReq(IR,SluiceMap(s,Outside))).Robot1;
	Robot1 = sum s:Sluice.((waferBroadcastReceived(SluiceMap(s, Inside), Projected) + waferBroadcastReceived(SluiceMap(s, Outside), Projected)).MoveReq(SluiceMap(s,Outside),OR) + 
							waferBroadcastReceived(IR, Unprojected).MoveReq(IR,SluiceMap(s,Outside))).Robot1;
   	Robot2  = sum s:Sluice.((waferBroadcastReceived(SluiceMap(s, Outside), Unprojected).MoveReq(SluiceMap(s,Inside),WR_I)+ (waferBroadcastReceived(WR_O, 													Projected)).MoveReq(WR_O,SluiceMap(s,Inside)))).Robot2;

	WaferPositionTracker(start: Bool, IRw: Wafer, ORw: Wafer, S1w: Wafer, S2w: Wafer, WRIw: Wafer, WROw: Wafer, IPSw: Wafer) = 
		(start) -> 
			waferBroadcastSent(IR, Unprojected).WaferPositionTracker(start = false, IRw = Unprojected)
			<>
		sum p: Position, w: Wafer.waferStatusUpdateReceived(p,w).(
			waferBroadcastSent(p,w).(
				(p == IR) ->
					WaferPositionTracker(IRw = w)
				+
				(p == OR) ->
					WaferPositionTracker(ORw = w)
				+
				(p == S1_In || p == S1_Out) ->
					WaferPositionTracker(S1w = w)
				+
				(p == S2_In || p == S2_Out) ->
					WaferPositionTracker(S2w = w)
				+
				(p == WR_I) ->
					WaferPositionTracker(WRIw = w)
				+
				(p == WR_O) ->
					WaferPositionTracker(WROw = w)
				+
				(p == IPS) ->
					WaferPositionTracker(IPSw = w)
			)
		); 
  
%WaferState(ps:PositionStatus) = sum src,des:Position.((src!=des)&&(des!=IR)&&(src!=OR))->WaferState(Update(ps,src,des));
  %Controller 

  %Controller = sum src,des:Position.((src!=des)&&sigOpen())->(MoveOK(src,des)).Controller;
  
 
init 
  hide({isClose,isOpen,sigOpen,sigClose},
  allow({Move,MoveThrough,closeDoor,isClose,isOpen,sigOpen,sigClose,pump,openDoor,Open,Close, waferBroadcast, waferStatusUpdate},
    comm({ 
	
   	MoveReq|MoveOK -> Move,
   	isOpen|sigOpen -> Open,
   	sigClose|isClose -> Close,
	waferStatusUpdateSent | waferStatusUpdateReceived -> waferStatusUpdate,
	waferBroadcastSent | waferBroadcastReceived -> waferBroadcast
  
      },
       Robot1 ||SluiceControl(S1,Outside)|| WaferPositionTracker(true, Empty, Empty, Empty, Empty, Empty, Empty, Empty)%||%Controller %sample simulation
    	)
    )
)
    ;
