

   
sort 
  Sluice = struct S1|S2; %the two sluices
  Robot = struct R1|R2; %the three robots
  DoorType = struct Inside|Outside; %the placement of the doors
  %WaitingRack = struct Unprojected ? isUnprojectedEmpty | Projected ? isProjectedEmpty; %waiting racks, with ways to check if they are empty or not
  %OutsideRack = struct Input|Output; %outside racks
  Position = struct IR|WR_I|WR_O|OR|IPS|S1_Out|S1_In|S2_Out|S2_In;
 % Status = struct Empty?isEmpty|Full|UnProjected|Projected?isProjected;
  %PositionStatus = Position -> Status;
  %Component = struct R1|R2;
  Wafer = struct Empty | Projected | Unprojected;


map 
  %GreenSig : Position -> Status;
  %SluiceDoor : Sluice # DoorType;
 % Initial : Position->Status;
  %Update : PositionStatus # Position # Position -> PositionStatus;
  SluiceMap : Sluice # DoorType -> Position;


var
  p:Position;
 % ps:PositionStatus;
  src,des:Position;
  %sd:SluiceDoor;


eqn
  %Initial(p)=Empty; 


  SluiceMap(S1,Outside)=S1_Out;
  SluiceMap(S1,Inside)=S1_In;
  SluiceMap(S2,Outside)=S2_Out;
  SluiceMap(S2,Inside)=S2_In;


  %Every Move of R1 and R2 from Src to Des results in Des_State = Src_State and Src_State=Empty
  %Update(ps,src,des) = ps[des->ps(src)][src->Empty];
  


act  
  closeDoor, openDoor,isClose,isOpen,signalOpen,signalClose,signalDoorStuck,SluiceOpen,SluiceClose,MoveThrough: Sluice # DoorType;
  pump: Sluice; %pumping the air out of a sluice
  Move,MoveOK,MoveReq: Position # Position;
  
	waferStatusUpdateSent, waferStatusUpdateReceived, waferStatusUpdate: Position # Wafer;
	waferBroadcastSent, waferBroadcastReceived, waferBroadcast: Position # Wafer;
  
  %doorStuck : Position;


proc 


  % S1 and S2 sequence : An outside door can be opened only if it was previously closed and the inside door is currently not open.
%An inside door can be opened only if it was previously closed and the outside door is currently not open.There is a pumping of air in sluice before inside door opening.
%A door can be closed if it was previously opened and it is not stuck.
								
	Sluice(s:Sluice, outsideDoor:Bool, insideDoor:Bool, outsideDoorStuck:Bool, insideDoorStuck:Bool) = ((!outsideDoorStuck&&!insideDoorStuck)->((!outsideDoor && !insideDoor) -> (signalOpen(s,Outside) . SluiceOpen(s,Outside) . 	Sluice(outsideDoor=true)) + (pump(s).signalOpen(s,Inside) . SluiceOpen(s,Inside) . Sluice(insideDoor=true)))
+
((outsideDoor && !insideDoor) -> (signalClose(s,Outside) . SluiceClose(s,Outside). Sluice(outsideDoor=false)))
+
((!outsideDoor && insideDoor) -> (signalClose(s,Inside) . SluiceClose(s,Inside) . Sluice(insideDoor=false))))  
+
(signalDoorStuck(s,Outside) . Sluice(outsideDoorStuck=true))
+
(signalDoorStuck(s,Inside) . Sluice(insideDoorStuck=true));				


  % R1 can pickup wafers only from IR,S1_Out or S2_Out and place wafers only S1_Out,S2_Out or OR
  % R2 can pickup wafers only from S1_In,S2_In,WR_I,WR_O and place wafers only S1_In,S2_In,WR_I
   %Robot1  =  sum s:Sluice.(((waferBroadcastReceived(SluiceMap(s, Inside), projected) + waferBroadcastReceived(SluiceMap(s, Outside), projected).(MoveReq(SluiceMap(s,Outside),OR) + 
	%						waferBroadcastReceived(IR, unprojected).MoveReq(IR,SluiceMap(s,Outside))).Robot1;
	Robot1 = sum s:Sluice.((waferBroadcastReceived(SluiceMap(s, Inside), Projected) + waferBroadcastReceived(SluiceMap(s, Outside), Projected)).MoveReq(SluiceMap(s,Outside),OR) + 
							waferBroadcastReceived(IR, Unprojected).MoveReq(IR,SluiceMap(s,Outside))).Robot1;
   	Robot2  = sum s:Sluice.((waferBroadcastReceived(SluiceMap(s, Outside), Unprojected).MoveReq(SluiceMap(s,Inside),WR_I)+ (waferBroadcastReceived(WR_O, 													Projected)).MoveReq(WR_O,SluiceMap(s,Inside)))).Robot2;


	WaferPositionTracker(start: Bool, IRw: Wafer, ORw: Wafer, S1w: Wafer, S2w: Wafer, WRIw: Wafer, WROw: Wafer, IPSw: Wafer) = 
		(start) -> 
			waferBroadcastSent(IR, Unprojected).WaferPositionTracker(start = false, IRw = Unprojected)
			<>
		sum p: Position, w: Wafer.waferStatusUpdateReceived(p,w).(
			waferBroadcastSent(p,w).(
				(p == IR) ->
					WaferPositionTracker(IRw = w)
				+
				(p == OR) ->
					WaferPositionTracker(ORw = w)
				+
				(p == S1_In || p == S1_Out) ->
					WaferPositionTracker(S1w = w)
				+
				(p == S2_In || p == S2_Out) ->
					WaferPositionTracker(S2w = w)
				+
				(p == WR_I) ->
					WaferPositionTracker(WRIw = w)
				+
				(p == WR_O) ->
					WaferPositionTracker(WROw = w)
				+
				(p == IPS) ->
					WaferPositionTracker(IPSw = w)
			)
		); 
  
%WaferState(ps:PositionStatus) = sum src,des:Position.((src!=des)&&(des!=IR)&&(src!=OR))->WaferState(Update(ps,src,des));
  %Controller 


  %Controller = sum src,des:Position.((src!=des)&&sigOpen())->(MoveOK(src,des)).Controller;
  
 
init 
  
  allow({Move,MoveThrough,closeDoor,SluiceOpen,SluiceClose,signalOpen,signalClose,signalDoorStuck,pump, waferBroadcast, waferStatusUpdate},
    comm({ 
	
   	MoveReq|MoveOK -> Move,
  
	waferStatusUpdateSent | waferStatusUpdateReceived -> waferStatusUpdate,
	waferBroadcastSent | waferBroadcastReceived -> waferBroadcast
  
      },
       Robot1 ||Sluice(S1,false,false,false,false)
%|| WaferPositionTracker(true, Empty, Empty, Empty, Empty, Empty, Empty, Empty)%||%Controller %sample simulation
    	)
    
)
    ;


