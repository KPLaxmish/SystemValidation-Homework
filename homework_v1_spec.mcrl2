

   
sort 
  Sluice = struct S1|S2; %the two sluices
  Robot = struct R1|R2; %the three robots
  DoorType = struct Inside|Outside; %the placement of the doors
  %WaitingRack = struct Unprojected ? isUnprojectedEmpty | Projected ? isProjectedEmpty; %waiting racks, with ways to check if they are empty or not
  %OutsideRack = struct Input|Output; %outside racks
  Position = struct IR|WR_I|WR_O|OR|IPS|S1_Out|S1_In|S2_Out|S2_In;
 % Status = struct Empty?isEmpty|Full|UnProjected|Projected?isProjected;
  %PositionStatus = Position -> Status;
  %Component = struct R1|R2;
  Wafer = struct Empty | Projected | Unprojected;


map 
  %GreenSig : Position -> Status;
  %SluiceDoor : Sluice # DoorType;
 % Initial : Position->Status;
  %Update : PositionStatus # Position # Position -> PositionStatus;
  SluiceMap : Sluice # DoorType -> Position;


var
  p:Position;
 % ps:PositionStatus;
  src,des:Position;
  %sd:SluiceDoor;


eqn
  %Initial(p)=Empty; 


  SluiceMap(S1,Outside)=S1_Out;
  SluiceMap(S1,Inside)=S1_In;
  SluiceMap(S2,Outside)=S2_Out;
  SluiceMap(S2,Inside)=S2_In;


  %Every Move of R1 and R2 from Src to Des results in Des_State = Src_State and Src_State=Empty
  %Update(ps,src,des) = ps[des->ps(src)][src->Empty];
  


act  
  	checkOpenReceived, checkOpenSent, checkOpen: Position; %This is a signal that the controller sends to sluices to check if they can be opened or not.
	sluiceSignalSent, sluiceSignalReceived, sluiceSignal: Bool # Position; %This is a signal that the sluice sends back to the controller related to the opening request. True means yes, it can be opened, false means it cannot be opened.
	commandClose,signalOpen,signalClosed,openDoor,closeDoor,signalDoorStuck,SluiceOpen,SluiceClose: Sluice # DoorType;
  pump: Sluice; %pumping the air out of a sluice
  Move,MoveOK,MoveReq: Position # Position; %MoveReq is used with MoveReqSent and MoveReqReceived

asd; % just a very simple test action, I used it after communications, can be useful while developing

	MoveReqSent, MoveReqReceived: Position # Position; % Request to move sent by the robots to the controller.
	MoveResponseSent, MoveResponseReceived, MoveResponse: Bool # Position # Position; % Response to the request, true means approved, false means denied.
	MoveDoneSent, MoveDoneReceived, MoveDone: Bool # Position # Position; %Signal from the robots to the controller that they are done moving.
  
    waferStatusUpdateSent, waferStatusUpdateReceived, waferStatusUpdate: Position # Wafer; %Sending an update to the wafer tracker about the changes in the wafer positions.
    waferBroadcastSent, waferBroadcastReceived, waferBroadcast: Position # Wafer; %Sending an update to the robots and the controller about the changes in the wafer positions.

	controllerWaferRequestSent, controllerWaferRequestReceived, controllerWaferRequest: Position;
	controllerWaferResponseSent, controllerWaferResponseReceived, controllerWaferResponse: Position # Wafer;
	beginProjection,endProjection,projectionUpdate,projectionUpdateSent,projectionUpdateReceived;
  
  %doorStuck : Position;


proc 


  % S1 and S2 sequence : An outside door can be opened only if it was previously closed and the inside door is currently not open.
%An inside door can be opened only if it was previously closed and the outside door is currently not open.There is a pumping of air in sluice before inside door opening.
%A door can be closed if it was previously opened and it is not stuck.
								
%CHANGES: I changed the signal sending: sluices first wait for an opening request from the Controller. After that, they open, and send back a message about the result of the opening process. I haven't touched the closing.


	Sluice(s:Sluice, outsideDoor:Bool, insideDoor:Bool, outsideDoorStuck:Bool, insideDoorStuck:Bool) = ((!outsideDoorStuck&&!insideDoorStuck)->(
		(!outsideDoor && !insideDoor) -> ((checkOpenReceived(SluiceMap(s,Outside)) . SluiceOpen(s,Outside).sluiceSignalSent(true, SluiceMap(s, Outside)) . Sluice(outsideDoor=true)) + (checkOpenReceived(SluiceMap(s,Inside)) . SluiceOpen(s,Inside).sluiceSignalSent(true, SluiceMap(s, Inside)) . Sluice(insideDoor=true))))
+
((outsideDoor && !insideDoor) -> (signalClosed(s,Outside) . SluiceClose(s,Outside). Sluice(outsideDoor=false)))
+
((!outsideDoor && insideDoor) -> (signalClosed(s,Inside) . SluiceClose(s,Inside) . Sluice(insideDoor=false))))  
+
(signalDoorStuck(s,Outside) . Sluice(outsideDoorStuck=true))
+
(signalDoorStuck(s,Inside) . Sluice(insideDoorStuck=true));				


  % R1 can pickup wafers only from IR,S1_Out or S2_Out and place wafers only S1_Out,S2_Out or OR
  % R2 can pickup wafers only from S1_In,S2_In,WR_I,WR_O and place wafers only S1_In,S2_In,WR_I
   %Robot1  =  sum s:Sluice.(((waferBroadcastReceived(SluiceMap(s, Inside), projected) + waferBroadcastReceived(SluiceMap(s, Outside), projected).(MoveReq(SluiceMap(s,Outside),OR) + 
	%						waferBroadcastReceived(IR, unprojected).MoveReq(IR,SluiceMap(s,Outside))).Robot1;


	Robot1 = sum s:Sluice.(waferBroadcastReceived(SluiceMap(s, Inside), Projected).MoveReqSent(SluiceMap(s,Outside),OR).
								(MoveResponseReceived(true, SluiceMap(s,Outside), OR).waferStatusUpdateSent(SluiceMap(s,Outside), Empty).waferStatusUpdateSent(OR, Projected).commandClose(s,Outside).MoveDoneSent(true, SluiceMap(s,Outside), OR) + 
								MoveResponseReceived(false, SluiceMap(s,Outside), OR).MoveDoneSent(false, SluiceMap(s,Outside), OR)) 

							+ 
	
							waferBroadcastReceived(IR, Unprojected).MoveReqSent(IR,SluiceMap(s,Outside)).(MoveResponseReceived(true,IR,SluiceMap(s,Outside)).waferStatusUpdateSent(SluiceMap(s,Outside),Unprojected).MoveDoneSent(true,IR,SluiceMap(s,Outside)).commandClose(s,Outside).pump(s)
							+ 
							MoveResponseReceived(false, IR, SluiceMap(s,Outside)).MoveDoneSent(false, IR, SluiceMap(s,Outside)))).Robot1;

   	Robot2  = sum s:Sluice.(waferBroadcastReceived(SluiceMap(s, Outside), Unprojected).MoveReqSent(SluiceMap(s,Inside),WR_I).asd.
						   		(MoveResponseReceived(true, SluiceMap(s,Inside), WR_I).waferStatusUpdateSent(WR_I, Unprojected).MoveDoneSent(true, SluiceMap(s,Inside), WR_I).commandClose(s,Inside))

+ 

waferBroadcastReceived(WR_O,Projected).MoveReqSent(WR_O,SluiceMap(s,Inside)).MoveResponseReceived(true,WR_O,SluiceMap(s,Inside)). waferStatusUpdateSent(SluiceMap(s,Inside),Projected).waferStatusUpdateSent(WR_O, Empty).commandClose(s,Inside)).Robot2;

	Robot3  = (waferBroadcastReceived(WR_I,Unprojected).MoveReqSent(WR_I,IPS).MoveResponseReceived(true,WR_I,IPS).waferStatusUpdateSent(IPS, Unprojected).MoveDoneSent(true, WR_I, IPS)

+ waferBroadcastReceived(IPS,Projected). MoveReqSent(IPS,WR_O).MoveResponseReceived(true,IPS,WR_O).waferStatusUpdateSent(WR_O, Projected).MoveDoneSent(true, IPS,WR_O)). Robot3;


	ImageProjectionSystem = (waferBroadcastReceived(IPS,Unprojected).beginProjection.endProjection.waferStatusUpdateSent(IPS, Projected)+
			(MoveReqReceived(IPS,WR_O).controllerWaferRequestSent(IPS).controllerWaferResponseReceived(IPS,Projected).MoveResponseSent(true, IPS, WR_O).MoveDoneSent(true, IPS, WR_O).MoveDoneReceived(true, IPS, WR_O))).ImageProjectionSystem; 

%For some godforsaken reason, this only works if I put the waferBroadcastSent inside the conditions.
	WaferPositionTracker(start: Bool, IRw: Wafer, ORw: Wafer, S1w: Wafer, S2w: Wafer, WRIw: Wafer, WROw: Wafer, IPSw: Wafer) = 
		((start) -> 
			(waferBroadcastSent(IR, Unprojected).WaferPositionTracker(start = false, IRw = Unprojected))
			<>
		(sum p: Position, w: Wafer.waferStatusUpdateReceived(p,w).(
			
				((p == IR) ->
					waferBroadcastSent(p,w).WaferPositionTracker(IRw = w))
				+
				((p == OR) ->
					waferBroadcastSent(p,w).WaferPositionTracker(ORw = w))
				+
				((p == S1_In || p == S1_Out) ->
					waferBroadcastSent(p,w).WaferPositionTracker(S1w = w))
				+
				((p == S2_In || p == S2_Out) ->
					waferBroadcastSent(p,w).WaferPositionTracker(S2w = w))
				+
				((p == WR_I) ->
					waferBroadcastSent(p,w).WaferPositionTracker(WRIw = w))
				+
				((p == WR_O) ->
					waferBroadcastSent(p,w).WaferPositionTracker(WROw = w))
				+
				((p == IPS) ->
					waferBroadcastSent(p,w).WaferPositionTracker(IPSw = w))
			
		))

		+ (sum p:Position.controllerWaferRequestReceived(p).(
			((p == IR) ->
					controllerWaferResponseSent(p,IRw).WaferPositionTracker())
				+
				((p == OR) ->
					controllerWaferResponseSent(p,ORw).WaferPositionTracker())
				+
				((p == S1_In || p == S1_Out) ->
					controllerWaferResponseSent(p,S1w).WaferPositionTracker())
				+
				((p == S2_In || p == S2_Out) ->
					controllerWaferResponseSent(p,S2w).WaferPositionTracker())
				+
				((p == WR_I) ->
					controllerWaferResponseSent(p,WRIw).WaferPositionTracker())
				+
				((p == WR_O) ->
					controllerWaferResponseSent(p,WROw).WaferPositionTracker())
				+
				((p == IPS) ->
					controllerWaferResponseSent(p,IPSw).WaferPositionTracker())
		))
		

		

); 

		%WaferBroadcaster(p: Position, w: Wafer) = 
  
%WaferState(ps:PositionStatus) = sum src,des:Position.((src!=des)&&(des!=IR)&&(src!=OR))->WaferState(Update(ps,src,des));
  %Controller 


%The controller ask sluices and rack positions whether robots can move ther or not. It sends a checkOpen to a sluice, which answers whether it can be opened or not. It sends back a sluiceSignal with the boolean being the answer. After this, the controller responds back to the robots, and waits for their acknowledgement. For the racks, it checks the wafer broadcasts to determine whether the destination sluice is open or not: THIS MIGHT NOT WORK, I HAVEN'T TESTED IT.
	Controller = (sum src, des: Position.MoveReqReceived(src, des).(controllerWaferRequestSent(src).
	(
	  (src!=des) ->
		(
		 ((src==IR)&&(des==S1_Out||des==S2_Out))->%Start of the entire process, when a move request is sent from IR to outside of Sluice
						(controllerWaferResponseReceived(src,Unprojected)).checkOpenSent(des).
							(sluiceSignalReceived(false, des). MoveResponseSent(false, src, des).MoveDoneReceived(false, src, des) 
							+ 				
							sluiceSignalReceived(true,des).MoveResponseSent(true, src, des). MoveDoneReceived(true, src,des)).Controller
			+
		  ((src==WR_I)->controllerWaferResponseReceived(src,Unprojected).MoveResponseSent(true, src, des).MoveDoneReceived(true, src,des))
			
			+
			(
			  ((des == S1_In||des==S2_In) ->%if the destination is inside doors the possible sources are outside doors with Unprojected wafer or WR_O with projected wafer
					((src==S1_Out||src==S2_Out)->
						((controllerWaferResponseReceived(src,Unprojected)).checkOpenSent(des).
							(sluiceSignalReceived(false,des).MoveResponseSent(false, src, des).MoveDoneReceived(false, src, des) 
							+ 
							sluiceSignalReceived(true,des). MoveResponseSent(true, src, des). MoveDoneReceived(true, src, des)).Controller)
				 
			     <> ((src == WR_O) -> 
						(controllerWaferResponseReceived(src,Projected)).checkOpenSent(des).
							(sluiceSignalReceived(false,des).MoveResponseSent(false, src, des).MoveDoneReceived(false, src, des) 
							+ 
							sluiceSignalReceived(true, des). MoveResponseSent(true, src, des). MoveDoneReceived(true, src, des)).Controller)
			 )  
			  +
			 ((src == S1_In || src == S2_In) -> %if the source is inside doors the possible destinations are outside doors(if src has Projected wafers) or WR_I if source has unprojected wafer
					((des == WR_I)->
					    (controllerWaferResponseReceived(src,Unprojected)).checkOpenSent(src).
							(sluiceSignalReceived(false,src).MoveResponseSent(false, src, des).MoveDoneReceived(false, src, des) 
							+ 
							(sluiceSignalReceived(true,src). MoveResponseSent(true, src, des). MoveDoneReceived(true, src, des))).Controller) 
                  
				 <> ((des == S1_Out||des==S2_Out) -> 
						(controllerWaferResponseReceived(src,Projected)).checkOpenSent(src).
							(sluiceSignalReceived(false, src).MoveResponseSent(false, src, des).MoveDoneReceived(false, src, des) 
							+ 
							sluiceSignalReceived(true,src).MoveResponseSent(true, src, des). MoveDoneReceived(true, src, des)).Controller)
			)
		 )
       )
	)))) ;
  
 
init 
  
  allow({Move,pump,SluiceOpen,SluiceClose,checkOpen,signalOpen,openDoor,closeDoor, waferBroadcast, waferStatusUpdate, MoveResponse, MoveDone, MoveReq, sluiceSignal,beginProjection,endProjection, controllerWaferRequest,controllerWaferResponse,projectionUpdate,asd,MoveReqSent},
    comm({ 
	
   %	MoveReq|MoveOK -> Move,
  	%signalOpen|checkOpen->openDoor,
	MoveReqSent | MoveReqReceived -> MoveReq,
	MoveResponseSent | MoveResponseReceived -> MoveResponse,
	MoveDoneSent | MoveDoneReceived -> MoveDone,
	sluiceSignalSent | sluiceSignalReceived -> sluiceSignal,
	checkOpenSent | checkOpenReceived -> checkOpen,
	commandClose|signalClosed->closeDoor,
	waferStatusUpdateSent | waferStatusUpdateReceived -> waferStatusUpdate,
	waferBroadcastSent | waferBroadcastReceived -> waferBroadcast,
	controllerWaferRequestSent | controllerWaferRequestReceived -> controllerWaferRequest,
	controllerWaferResponseSent | controllerWaferResponseReceived -> controllerWaferResponse,
  	projectionUpdateSent|projectionUpdateReceived -> projectionUpdate
      },
       Robot1 || Robot2 ||Robot3|| ImageProjectionSystem||Sluice(S1,false,false,false,false)||Sluice(S2,false,false,false,false)||Controller|| WaferPositionTracker(true, Empty, Empty, Empty, Empty, Empty, Empty, Empty)%||%Controller %sample simulation
    	)
    
)
    ;


